# [51. N 皇后](https://leetcode-cn.com/problems/n-queens/)、[52. N皇后 II](https://leetcode-cn.com/problems/n-queens-ii/)

### [51. N 皇后](https://leetcode-cn.com/problems/n-queens/)

> n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。
>
> 给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。
>
> 每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。

**示例 1：**

![image-20210620143856740](https://cdn.jsdelivr.net/gh/shimengjie/image-repo//imgimage-20210620143856740.png)

```tex
输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
解释：如上图所示，4 皇后问题存在两个不同的解法。
```

**示例 2：**

```tex
输入：n = 1
输出：[["Q"]]
```

### [52. N皇后 II](https://leetcode-cn.com/problems/n-queens-ii/)

> **n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。
>
> 给你一个整数 `n` ，返回 **n 皇后问题** 不同的解决方案的数量。

**示例 1：**

```tex
输入：n = 4
输出：2
解释：如上图所示，4 皇后问题存在两个不同的解法。
```

**示例 2：**

```tex
输入：n = 1
输出：1
```

## 分析阶段

经典的”N皇后“问题，之前第一次做的时候完全不知道如何下手，现在翻译一下就是：

在一个二维数组中，找到N个元素组成一个组合，要求这些元素下标满足以下要求：行下标互不相等、列下标互不相等、任意两元素不在同一条斜线上。

典型的“在元素集合中寻找满足条件的组合”。

### 1、问题类型

第二类：对某种数结构和算法的使用

使用的算法：在给定的元素集合中，找到所有满足条件的组合，使用“回溯算法“

数据结构：回溯算法需要构建空间状态树，使用树结构

### 2、解题思路

“回溯算法”要确定以下条件，然后构建出解集的空间状态树。

（1）选择列表

二维数组中所有的$N^2$个元素。

（2）路径

记录已经选择的元素、已选择的行下标、已选择的列下标、已选择的斜线。

**（3）结束条件**

达到什么条件时结束结束当前节点的遍历？

路径中元素个数等于N。

**（4）选择**

什么条件下才把当前元素添加进路径中？

在每一行执行递归，每次递归从列下标0开始，遍历当前行的每一列元素，选择条件：

* 当前元素所在的列没有被选择
* 当前元素所在的斜线上，没有其他元素被选择

**第二个条件：怎么判断两个元素在同一个斜线上？**

一个二维数组中有两个方向的斜线，如下图所示，都是行下标和列下标之间的一个线性函数，下图中两个线性函数为：

$y=x+k1、y=-x+k2  \rightarrow k1=y-x,k2=y+x$

如果两个元素在同一个斜线上，那么它们的 $k1,k2$ 值相等。

<img src="https://cdn.jsdelivr.net/gh/shimengjie/image-repo//imgimage-20210620151633825.png" alt="image-20210620151633825" style="zoom: 67%;" />



"空间状态树"如下图所示，图中$n=4$：

![image-20210620152252425](https://cdn.jsdelivr.net/gh/shimengjie/image-repo//imgimage-20210620152252425.png)

每一行都会有一层递归，每层递归都要遍历每列的元素，判断是否满足选择条件。

## 编码阶段

### Q_51

```java
public class Solution {

    public static void main(String[] args) {
        int n = 4;
        System.out.println("======" + new Solution().solveNQueens(n));
    }

    public List<List<String>> solveNQueens(int n) {
        List<List<String>> res = new ArrayList<>();
        List<Node> nodes = new ArrayList<>(n);
		// 记录已经选择的列
        boolean[] cols = new boolean[n];
        Arrays.fill(cols, false);
		// 已经选择的斜线
        Set<Integer> k1 = new HashSet<>();
        Set<Integer> k2 = new HashSet<>();

        backtrack(res, nodes,  cols, k1, k2, 0, n);

        return res;
    }

    public void backtrack(List<List<String>> res, List<Node> nodes, boolean[] cols,
                          Set<Integer> k1, Set<Integer> k2, int row, int n) {
        if (nodes.size() == n) {
            List<String> str = nodes.stream().map(Node::toString).collect(Collectors.toList());
            res.add(str);
            return;
        }

        for (int col = 0; col < n; col++) {
            if (cols[col]) {
                continue;
            }

            Node node = new Node(row, col, n);
            if (k1.contains(node.getK1())) {
                continue;
            }
            if (k2.contains(node.getK2())) {
                continue;
            }

            nodes.add(node);
            cols[col] = true;
            k1.add(node.getK1());
            k2.add(node.getK2());
            backtrack(res, nodes,  cols, k1, k2, row + 1, n);

            nodes.remove(nodes.size() - 1);
            cols[col] = false;
            k1.remove(node.getK1());
            k2.remove(node.getK2());
        }
    }
    
    public static class Node {
        int row;
        int col;
        int n;

        public Node(int row, int col, int n) {
            this.row = row;
            this.col = col;
            this.n = n;
        }

        public int getCol() {
            return col;
        }

        public int getK1() {
            return row + col;
        }

        public int getK2() {
            return row - col;
        }

        @Override
        public String toString() {
            char[] chs = new char[n];
            Arrays.fill(chs, '.');
            chs[col] = 'Q';
            return new String(chs);
        }
    }
}
```

### Q_52

```java
public class Solution {

    public static void main(String[] args) {
        int n = 4;
        System.out.println("======" + new Solution().totalNQueens(n));
    }


    public int totalNQueens(int n) {
        List<Node> nodes = new ArrayList<>(n);

        boolean[] cols = new boolean[n];
        Arrays.fill(cols, false);

        Set<Integer> k1 = new HashSet<>();
        Set<Integer> k2 = new HashSet<>();

        return backtrack(nodes, cols, k1, k2, 0, n);
    }

    public int backtrack(List<Node> nodes, boolean[] cols,
                         Set<Integer> k1, Set<Integer> k2, int row, int n) {
        if (nodes.size() == n) {
            return 1;
        }

        int count = 0;
        for (int col = 0; col < n; col++) {
            if (cols[col]) {
                continue;
            }

            Node node = new Node(row, col);
            if (k1.contains(node.getK1())) {
                continue;
            }
            if (k2.contains(node.getK2())) {
                continue;
            }

            nodes.add(node);
            cols[col] = true;
            k1.add(node.getK1());
            k2.add(node.getK2());
            count += backtrack(nodes, cols, k1, k2, row + 1, n);

            nodes.remove(nodes.size() - 1);
            cols[col] = false;
            k1.remove(node.getK1());
            k2.remove(node.getK2());
        }
        return count;
    }

    public static class Node {
        int row;
        int col;

        public Node(int row, int col) {
            this.row = row;
            this.col = col;
        }

        public int getK1() {
            return row + col;
        }

        public int getK2() {
            return row - col;
        }
    }
}
```

## 总结阶段

“N皇后”问题是经典的“回溯”问题，确定选择列表、选择条件之后，使用递归实现，会很简单。