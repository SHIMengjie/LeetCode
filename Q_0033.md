# 33. Search in Rotated Sorted Array

> There is an integer array `nums` sorted in ascending order (with **distinct** values).
>
> Prior to being passed to your function, `nums` is **rotated** at an unknown pivot index `k` (`0 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,5,6,7]` might be rotated at pivot index `3` and become `[4,5,6,7,0,1,2]`.
>
> Given the array `nums` **after** the rotation and an integer `target`, return *the index of* `target` *if it is in* `nums`*, or* `-1` *if it is not in* `nums`.
>
> You must write an algorithm with `O(log n)` runtime complexity.

**Example 1:**

```
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
```

**Example 2:**

```
Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
```

**Example 3:**

```
Input: nums = [1], target = 0
Output: -1
```



## 解法

返回当前序列在“字典序”中的下一个序列。



按照“字典序算法”生成下一个序列，**字典序生成全排列的过程：**

① 将N个元素从小到大递增排序，形成有序序列，这是字典中最小的排列$A$；

② 在$A$的有序部分，寻找最后一个满足$A[i]<A[i+1]$的元素$A[i]$；

③ 在$A[i+1,N-1]$范围内找到大于$A[i]$的最小数$A[j]$，交换$A[i]$与$A[j]$；

④ 对$A[i+1,N-1]$范围内的元素进行翻转，得到字典序中的下一个序列；

⑤ 重复步骤②~④，直到所有元素按照从大到小逆序排列，全排列完成。

字典序生成全排列类似于动态规划，根据已知的第一个序列，生成下一个序列。

### 代码实现

```java
public static void nextPermutation(int[] nums) {
    int len = nums.length;
    int i = len - 2;
    // 从前向后找到最后一组正序，等价于从后向前找第一组逆序
    while (i >= 0 && nums[i] >= nums[i + 1]) {
        i--;
    }
    // 翻转倒序数组
    if (i < 0) {
        reverse(nums, 0, len - 1);
        return;
    }
    // 从后向前找到大于 nums[i] 的最小的数
    int j = len - 1;
    while (j > i + 1 && nums[j] <= nums[i]) {
        j--;
    }
    swap(nums, i, j);
    reverse(nums, i + 1, len - 1);
}

/**
     * 翻转数组
     *
     * @param arr   数组
     * @param begin 开始下标
     * @param end   结束下标
     */
private static void reverse(int[] arr, int begin, int end) {
    while (begin < end) {
        swap(arr, begin, end);
        begin++;
        end--;
    }
}

/**
     * 交换数组中的两个元素
     *
     * @param nums 数组
     * @param idx1 下标1
     * @param idx2 下标2
     */
private static void swap(int[] nums, int idx1, int idx2) {
    int tmp = nums[idx1];
    nums[idx1] = nums[idx2];
    nums[idx2] = tmp;
}
```

时间复杂度：$O(N)$

## 总结

直接使用“字典序算法”生成下一个序列。