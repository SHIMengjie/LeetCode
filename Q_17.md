# [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

> 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。
>
> 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
>
> <img src="https://cdn.jsdelivr.net/gh/shimengjie/image-repo//img/17_telephone_keypad.png" alt="img" style="zoom:50%;" />
>
> 

**示例 1：**

```tex
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

**示例 2：**

```tex
输入：digits = ""
输出：[]
```

**示例 3：**

```tex
输入：digits = "2"
输出：["a","b","c"]
```

## 分析阶段



### 1、问题类型



### 2、解题思路

IP地址由4段数字组成：A.B.C.D，求解该题就是在在一个字符串中，确定IP地址中每一段数字，在字符串中对应的返回。

方法 $backtrack(res,path,s,ipSeg,start)$ 表示：在字符串 $s$ 中，从下标 $start$ 开始，查找IP中的第 $ipSeg (0 \le ipSeg \le 3)$ 段的数据。

接下来，确定“回溯算法”必需的一些要素，最后用代码实现。

（1）选择列表

整个字符串作为备选的元素，通过符号 "." 来划分字符串，每个元素只能使用一次。

（2）路径

记录 IP 中每段数字。

**（3）结束条件**

当 $ipSeg\gt 3$ 时，表示 IP 地址的所有段数字都已经确定了，这时要根据 $start$ 来判断是直接结束，还是把路径添加到结果集中：

* 如果 $start == s.length()$，表示字符串中所有元素都已经遍历过，可以把路径添加到结果集中
* 否则，就丢弃当前路径

**（4）选择**

什么条件下才把当前遍历的数字添加到路径中？

根据 IP 地址的要求，数字满足下面条件才能添加进路径：

* 位数在[1,3]之间
* 值在[0,255] 之间
* 如果只有1位，可以以 0 开头
* 如果超过1位，不能以 0 开头

（5）空间状态树

下图中字符串为 “101023”。

![image-20210630234052145](https://cdn.jsdelivr.net/gh/shimengjie/image-repo//img/image-20210630234052145.png)

## 编码阶段

```java
public class Solution {

    Map<Character, String> map = new HashMap<Character, String>(8) {
        {
            put('2', "abc");
            put('3', "def");
            put('4', "ghi");
            put('5', "jkl");
            put('6', "mno");
            put('7', "pqrs");
            put('8', "tuv");
            put('9', "wxyz");
        }
    };

    public static void main(String[] args) {
        String s = "6";
        System.out.println("========" + new Solution().letterCombinations(s));
    }

    public List<String> letterCombinations(String digits) {
        if (digits == null || digits.length() == 0) {
            return new ArrayList<>();
        }

        List<String> res = new ArrayList<>(digits.length());

        backtrack(digits, res, new ArrayList<>(digits.length()), 0);
        return res;
    }

    private void backtrack(String digits, List<String> res, List<Character> path, int idx) {
        if (idx == digits.length()) {
            res.add(path.stream().map(Object::toString).collect(Collectors.joining()));
            return;
        }

        String subString = map.get(digits.charAt(idx));
        for (int i = 0; i < subString.length(); i++) {
            path.add(subString.charAt(i));
            backtrack(digits, res, path, idx + 1);
            path.remove(path.size() - 1);
        }
    }
}
```

## 总结阶段
